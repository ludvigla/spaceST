#' Quality Control statistics
#'
#' @description Given a data.frame with gene expression values (genes as rows and observations as columns), this function will return a
#' data.frame with unique genes and transcript counts for each observation, as well as the sample id
#' @param df Input gene expression data.frame
#' @return Data.frame with unique genes per feature and transcripts per feature
#' @export
ST_statistics<- function(df){
  stopifnot(
    is.data.frame(df)
  )
  samples <- as.numeric(do.call(rbind, strsplit(colnames(df), split = "_"))[, 1])
  unique.genes.per.feature <- apply(df, 2, function(x) sum(x > 0))
  transcripts.per.feature <- colSums(df)
  return(data.frame(unique.genes.per.feature, transcripts.per.feature, samples))
}

#' Quality Control plot
#'
#' @description This function plots histograms of unique genes per feature and transcripts per featrure.
#' @importFrom cowplot plot_grid
#' @param df Input quality control data.frame.
#' @return Plot of histograms.
#' @export
ST_statistics.plot <- function(df, separate = F){
  theme_none <- ggplot2::theme(axis.line = ggplot2::element_line(colour = "black"),
                      panel.grid.major = ggplot2::element_blank(),
                      panel.grid.minor = ggplot2::element_blank(),
                      panel.border = ggplot2::element_blank(),
                      panel.background = ggplot2::element_blank())
  if (separate == T) {
    p1 <- ggplot2::ggplot(df, ggplot2::aes(x = unique.genes.per.feature)) +
      ggplot2::geom_histogram(bins = 30, fill = scales::muted("dark blue"), color = "black") +
      theme_none +
      ggplot2::scale_color_manual(name = "", values = c(median = "black")) +
      ggplot2::facet_grid(~samples)

    p2 <- ggplot2::ggplot(df, ggplot2::aes(x = transcripts.per.feature)) +
      ggplot2::geom_histogram(bins = 30, fill = scales::muted("red"), color = "black") +
      theme_none +
      ggplot2::scale_color_manual(name = "", values = c(median = "black")) +
      facet_grid(~samples)
  } else {
    p1 <- ggplot2::ggplot(df, ggplot2::aes(x = unique.genes.per.feature)) +
      ggplot2::geom_histogram(bins = 30, fill = scales::muted("dark blue"), color = "black") +
      ggplot2::geom_vline(ggplot2::aes(xintercept = median(df$unique.genes.per.feature), colour = "median"),
                          linetype="dashed",
                          size=1) +
      theme_none +
      ggplot2::scale_color_manual(name = "", values = c(median = "black"))

    p2 <- ggplot2::ggplot(df, ggplot2::aes(x = transcripts.per.feature)) +
      ggplot2::geom_histogram(bins = 30, fill = scales::muted("red"), color = "black") +
      ggplot2::geom_vline(ggplot2::aes(xintercept = median(df$transcripts.per.feature), colour = "median"),
                          linetype="dashed",
                          size=1) +
      theme_none +
      ggplot2::scale_color_manual(name = "", values = c(median = "black"))
  }
  p <- cowplot::plot_grid(p1, p2, nrow = 2)
  plot(p)
}

#' Obtain coordinates from expression data list of expression data.frame
#'
#' @title
#' get_coordinates: obtain spatial coordinates
#'
#' @description
#' This function is used to collect all coordinates from a list of expression datasets or an expression dataset
#'
#' @param x List of expression data.coords <- ge_cooframes, data.frame or matrix.
#' @return Data frame with replicate numbers, x and y coordinates
#'
#' @rdname get_coordinates
#' @export get_coordinates
get_coordinates <- function(x, rep = TRUE) {
  UseMethod("get_coordinates")
}
#' @rdname get_coordinates
#' @export
get_coordinates.matrix <- function(x, rep = TRUE){
  get_coordinates.data.frame(x, rep = TRUE)
}
#' @rdname get_coordinates
#' @export
get_coordinates.data.frame <- function(x, rep = TRUE){
    ids <- colnames(x)
    coords <- as.data.frame(do.call(rbind, strsplit(ids, split = "_")))
    coords[, 2] <- as.numeric(as.character(coords[, 2]))
    coords[, 3] <- as.numeric(as.character(coords[, 3]))
    colnames(coords) <- c("replicate", "x", "y")
    if (rep) {
      return(coords)
    } else {
      return(coords[, 2:3])
    }
}
#' @rdname get_coordinates
#' @export
get_coordinates.spaceST <- function(x, rep = TRUE){
  if (nrow(x@corrected) == 0) {
    get_coordinates.data.frame(x@expr, rep = rep)
  } else {
    get_coordinates.data.frame(x@corrected, rep = rep)
  }
}
#' @export
get_coordinates.list <- function(x, rep = TRUE) {
  coords_list <- list()
  for (i in 1:length(x)) {
    coords_list[[i]] <- get_coordinates(x[[i]], rep = rep)
  }
  return(as.data.frame(do.call(rbind, coords_list)))
}

#' Merge and filter expression datasets
#'
#' @description This function is used to merge datasets in a list of expression datasets.
#' Genes which are not present in some datasets will get 0 values in those datasets. The merged dataset is
#' subsequently filtered from features with few unique genes and genes with low expression counts.
#' @param x List of exrpression data frames.
#' @param unique.genes Integer value specifying number of unique genes allowed in a feature.
#' @param min.exp Integer value specifying lowest expression value allowed in min.features number of features.
#' @param min.features Integer value specifying number of features allowed with min.exp count.
#' @param filter.data Character vector specifying genes that should be filtered out.
#' @return Merged and filtered dataframe.
#' @export
merge_exp_list <- function(x,
                       unique.genes,
                       min.exp,
                       min.features,
                       filter.data){
  for (i in 1:length(x)){
    df <- x[[i]]
    # Order gene names alphabetically
    df <- df[order(rownames(df)), ]
    # Add index row
    df <- as.data.frame(cbind(id = rownames(df), df))
    x[[i]] <- df
  }
  df.A <- x[[1]]
  for (i in 2:length(x)){
    df.B <- x[[i]]
    df.A <- merge(df.A, df.B, by = "id", all = TRUE)
  }
  gene.names <- df.A$id
  # remove id column
  sample.df <- df.A[, -1]
  sample.df <- apply(sample.df, 2, as.numeric)
  rownames(sample.df) <- gene.names
  sample.df[is.na(sample.df)] <- 0
  if (!is.null(filter.data)){
    sample.df = sample.df[!rownames(sample.df) %in% filter.data,]
  }

  # Filter out low quality genes
  sample.df = sample.df[rowSums(sample.df >= min.exp) >= min.features,]
  sample.df <- as.data.frame(sample.df)

  # Filter out low quality features
  indices <- which(apply(sample.df, 2, function(x) sum(x > 0)) < unique.genes)
  if (length(indices) > 0){
    filtered.sample.df <- sample.df[, -indices]
  } else {
    filtered.sample.df <- sample.df
  }
  return(filtered.sample.df)
}

#'  pca of expression data
#'
#' @description This function is used to  the first two principal components of an expression dataset, or a comparison
#' between raw expression and corrected expression data.
#' @param df1 Expression dataset 1
#' @param df2 Expression dataset 2
#' @param samples Vector of replicate numbers of length ncol(filtered)
#' @param ... arguments passed to plotPCA function from scater
#' @importFrom Biobase pData
#' @importFrom scater newSCESet plotPCA
#' @importFrom cowplot plot_grid
#' @return Scatter plot of PC1 and PC2.
pca_plot <- function(df1, df2 = NULL, samples, ...){
  sce.raw = newSCESet(countData = df1)
  pData(sce.raw)$replicate = samples
  p1 <- plotPCA(sce.raw, pca_data_input = "counts", colour_by = "replicate", ...)
  if (!is.null(df2)) {
    sce.batch.corr = newSCESet(countData = df2)
    pData(sce.batch.corr)$replicate = samples
    p2 <- plotPCA(sce.batch.corr, pca_data_input="counts", colour_by = "replicate", ...)
    p <- plot_grid(p1, p2, nrow = 2, label_size = 10,
                            labels = c(paste("      raw data"),
                                       paste("batch corrected")))
  } else {
    p <- p1
  }
  plot(p)
}

#' Convert coordinates produced from json
#'
#' @description Use this funciton to convert coordinate names starting with X and add replicate
#' number.
#' @param df Dataframe with json headers.
#' @param rep Integer value specifying replicate number.
#' @return Return data.frame with modified headers.
#' @export
convert_coordinates_from_json <- function(df, rep) {
  res <- strsplit(colnames(df), split = "X")
  res <- paste(rep(rep, ncol(df)), do.call(rbind, res)[, 2], sep = "_")
  colnames(df) <- gsub(x = res, pattern = "x", replacement = "_")
  return(df)
}

#' Convert from ENSEMBL ID to HGNC symbol
#'
#' @description  Function used to convert ENSEMBL gene ids of an expression matrix into HGNC symbols.
#' @param df Data.frame or matrix with ENSEMBL ids as rownames.
#' @return Data.frame or matrix with converted names.
#' @importFrom biomaRt useDataset getBM
#' @export
ensembl2hgnc <- function(df) {
  UseMethod("ensembl2hgnc")
}
#' @export
ensembl2hgnc.data.frame <- function(df) {
  mart <- useDataset("hsapiens_gene_ensembl", useMart("ensembl"))
  G_list <- getBM(filters= "ensembl_gene_id", attributes= c("ensembl_gene_id", "hgnc_symbol"), values = rownames(df), mart = mart)
  merged.df <- aggregate(x = df, by = list(G_list[, 1]), sum, na.rm = TRUE)
  rownames(merged.df) <- merged.df$`Group.1`
  return(merged.df[, 2:ncol(df)])
}
#' @export
ensembl2hgnc.list <- function(df) {
  exp.list <- list()
  for (i in length(df)) {
    exp.list[[i]] <- ensembl2hgnc(df[[i]])
  }
}

#' Cast merged data to list of matrixes
#'
#' @description Cast any merged data.frame/matrix into a list of matrices for each replicate.
#' @param df Merged data.frame/matrix with spaceST headers, i.e. features as columns.
#' @return List of matrices.
#' @export
cast2list <- function(df) {
  samples <- as.integer(as.character(get_coordinates(df)[, 1]))
  exp.list <- list()
  for (i in unique(samples)) {
    print(i)
    indices <- (1:ncol(df))[which(samples == i)]
    exp.list[[i]] <- df[, indices]
  }
  return(exp.list)
}

#' Rename rownames of lists
#'
#' @description Rename colnames or rownames of list.
#' @param x input list to rename element for.
#' @param ref.list List to take names from.
#' @param type Character specifying which names of x to change.
#' @param ref.list.type Character specifying which names of ref.list to change.
#' @export
rename_list <- function(x, ref.list, type = "rownames", ref.list.type = "colnames") {
  renamed.list <- list()
  for (i in 1:length(x)) {
    df <- x[[i]]
    if (type == "rownames") {
      if (ref.list.type == "colnames") {
        rownames(df) <- colnames(ref.list[[i]])
      } else if (ref.list.type == "rownames") {
        rownames(df) <- rownames(ref.list[[i]])
      }
    } else if (type == "colnames") {
      if (ref.list.type == "colnames") {
        colnames(df) <- colnames(ref.list[[i]])
      } else if (ref.list.type == "rownames") {
        colnames(df) <- rownames(ref.list[[i]])
      }
    }
    renamed.lsit[[i]] <- df
  }
  return(renamed.list)
}

#' Normalize using CPTK method
#'
#' @description Function used to normalize ST data using Counts Per Ten thousand method
#' @param expr_mat Expression data.frame or matrix.
#' @return Normalized data.frame or matrix.
#' @export
calc_cpm <- function (expr_mat) {
  norm_factor <- colSums(expr_mat)
  return(t(t(expr_mat)/norm_factor)*10^4)
}
