RunModularityClustering <- function (object, SNN = matrix(), modularity = 1, resolution = 0.8, 
          algorithm = 1, n.start = 100, n.iter = 10, random.seed = 0, 
          print.output = TRUE, temp.file.location = NULL) 
{
  seurat.dir <- system.file(package = "Seurat")
  ModularityJarFile <- paste0(seurat.dir, "/java/ModularityOptimizer.jar")
  seurat.dir.base <- strsplit(x = seurat.dir, split = "/")[[1]]
  seurat.dir <- paste0(seurat.dir.base[0:(length(x = seurat.dir.base) - 
                                            1)], collapse = "/")
  seurat.dir <- paste0(seurat.dir, "/")
  diag(x = SNN) <- 0
  if (is.object(x = SNN)) {
    SNN <- as(object = SNN, Class = "dgTMatrix")
    edge <- cbind(i = SNN@j, j = SNN@i, x = SNN@x)
  }
  else {
    swap <- which(x = SNN != 0, arr.ind = TRUE) - 1
    temp <- swap[, 1]
    swap[, 1] <- swap[, 2]
    swap[, 2] <- temp
    edge <- cbind(swap, SNN[which(x = SNN != 0, arr.ind = TRUE)])
  }
  rownames(x = edge) <- NULL
  colnames(x = edge) <- NULL
  edge <- edge[!duplicated(x = edge[, 1:2]), ]
  temp.file.location <- SetIfNull(x = temp.file.location, default = seurat.dir)
  unique_ID <- sample(x = 10000:99999, size = 1)
  edge_file <- paste0(temp.file.location, "edge_", unique_ID, 
                      ".txt")
  output_file <- paste0(temp.file.location, "output_", unique_ID, 
                        ".txt")
  while (file.exists(edge_file)) {
    unique_ID <- sample(x = 10000:99999, size = 1)
    edge_file <- paste0(temp.file.location, "edge_", unique_ID, 
                        ".txt")
    output_file <- paste0(temp.file.location, "output", unique_ID, 
                          ".txt")
  }
  if (print.output) {
    print.output <- 1
  }
  else {
    print.output <- 0
  }
  write.table(x = edge, file = edge_file, sep = "\t", row.names = FALSE, 
              col.names = FALSE)
  if (modularity == 2 && resolution > 1) {
    stop("error: resolution<1 for alternative modularity")
  }
  command <- paste("java -jar", shQuote(string = ModularityJarFile), 
                   shQuote(string = edge_file), shQuote(string = output_file), 
                   modularity, resolution, algorithm, n.start, n.iter, random.seed, 
                   print.output)
  system(command, wait = TRUE)
  ident.use <- read.table(file = output_file, header = FALSE, 
                          sep = "\t")[, 1]
  object <- SetIdent(object = object, cells.use = object@cell.names, 
                     ident.use = ident.use)
  file.remove(edge_file)
  file.remove(output_file)
  return(object)
}

BuildSNN <- function(
  object,
  genes.use = NULL,
  reduction.type = "pca",
  dims.use = NULL,
  k.param = 10,
  k.scale = 10,
  plot.SNN = FALSE,
  prune.SNN = 1/15,
  print.output = TRUE,
  force.recalc = FALSE
) {
  data.use <- object.embed
  parameters.to.store <- as.list(environment(), all = TRUE)[names(formals("BuildSNN"))]
  parameters.to.store$object <- NULL
  parameters.to.store$distance.matrix <- NULL
  parameters.to.store$print.output <- NULL
  if (CalcInfoExists(object, "BuildSNN") && ! force.recalc){
    old.parameters <- GetAllCalcParam(object, "BuildSNN")
    old.parameters$time <- NULL
    old.parameters$print.output <- NULL
    if(all(all.equal(old.parameters, parameters.to.store) == TRUE)){
      warning("Build parameters exactly match those of already computed and stored SNN. To force recalculation, set force.recalc to TRUE.")
      return(object)
    }
  }
  object <- SetCalcParams(object = object,
                          calculation = "BuildSNN",
                          ... = parameters.to.store)
  n.cells <- nrow(x = data.use)
  if (n.cells < k.param) {
    warning("k.param set larger than number of cells. Setting k.param to number of cells - 1.")
    k.param <- n.cells - 1
  }
  # find the k-nearest neighbors for each single cell
  if (is.null(x = distance.matrix)) {
    my.knn <- get.knn(
      data <- as.matrix(x = data.use),
      k = min(k.scale * k.param, n.cells - 1)
    )
    nn.ranked <- cbind(1:n.cells, my.knn$nn.index[, 1:(k.param-1)])
    nn.large <- my.knn$nn.index
  } else {
    cat("Building SNN based on a provided distance matrix\n", file = stderr())
    n <- nrow(x = distance.matrix)
    k.for.nn <- k.param * k.scale
    knn.mat <- matrix(data = 0, ncol = k.for.nn, nrow = n)
    knd.mat <- knn.mat
    for (i in 1:n){
      knn.mat[i, ] <- order(data.use[i, ])[1:k.for.nn]
      knd.mat[i, ] <- data.use[i, knn.mat[i, ]]
    }
    nn.large <- knn.mat[, 2:(min(n, k.for.nn))]
    nn.ranked <- knn.mat[, 1:k.param]
  }
  w <- CalcSNNSparse(
    cell.names = rownames(data.use),
    k.param = k.param,
    nn.large = nn.large,
    nn.ranked = nn.ranked,
    prune.SNN = prune.SNN,
    print.output = TRUE
  )
  object@snn <- w
  if (plot.SNN) {
    if(!"tsne" %in% names(object@dr)) {
      warning("Please compute a tSNE for SNN visualization. See RunTSNE().")
    } else {
      if (nrow(object@dr$tsne@cell.embeddings) != length(x = object@cell.names)) {
        warning("Please compute a tSNE for SNN visualization. See RunTSNE().")
      } else {
        net <- graph.adjacency(
          adjmatrix = as.matrix(w),
          mode = "undirected",
          weighted = TRUE,
          diag = FALSE
        )
        plot.igraph(
          x = net,
          layout = as.matrix(x = res),
          edge.width = E(graph = net)$weight,
          vertex.label = NA, vertex.color = ident.use,
          vertex.size = 3
        )
      }
    }
  }
  return(object)
}

GetCellEmbeddings <- function (df, reduction.type = "pca", dims.use = NULL, cells.use = NULL) 
{
  object.embed <- GetDimReduction(object = object, reduction.type = "pca", 
                                  slot = "cell.embeddings")
  if (length(x = object.embed) == 0) {
    stop(paste0("Cell embeddings slot for ", reduction.type, 
                " is empty."))
  }
  cells.use <- SetIfNull(x = NULL, default = rownames(x = object.embed))
  if (any(!cells.use %in% rownames(x = object.embed))) {
    missing.cells <- paste0(cells.use[which(x = !cells.use %in% 
                                              rownames(x = object.embed))], collapse = ", ")
    warning(paste0("Could not find the following cell names: ", 
                   missing.cells))
    cells.use <- intersect(x = cells.use, y = rownames(x = object.embed))
  }
  dims.use <- SetIfNull(x = dims.use, default = 1:ncol(x = object.embed))
  if (any(!dims.use %in% 1:ncol(x = object.embed))) {
    missing.dims <- paste0(dims.use[which(x = !dims.use %in% 
                                            1:ncol(x = object.embed))], collapse = ", ")
    stop(paste0("Could not find the following dimensions: ", 
                missing.dims))
  }
  object.embed <- object.embed[cells.use, dims.use, drop = FALSE]
  object.key <- GetDimReduction(object = object, reduction.type = reduction.type, 
                                slot = "key")
  if (length(x = object.key) == 0) {
    colnames(x = object.embed) <- NULL
  }
  else {
    colnames(x = object.embed) <- paste0(object.key, dims.use)
  }
  return(object.embed)
}

CalcSNNSparse <- function (cell.names, k.param, nn.large, nn.ranked, prune.SNN, 
                           print.output) 
{
  n.cells <- length(cell.names)
  counter <- 1
  idx1 <- vector(mode = "integer", length = n.cells^2/k.param)
  idx2 <- vector(mode = "integer", length = n.cells^2/k.param)
  edge.weight <- vector(mode = "double", length = n.cells^2/k.param)
  id <- 1
  if (print.output) {
    print("Constructing SNN")
    pb <- txtProgressBar(min = 0, max = n.cells, style = 3)
  }
  for (i in 1:n.cells) {
    for (j in 1:ncol(x = nn.large)) {
      s <- intersect(x = nn.ranked[i, ], y = nn.ranked[nn.large[i, 
                                                                j], ])
      u <- union(nn.ranked[i, ], nn.ranked[nn.large[i, 
                                                    j], ])
      e <- length(x = s)/length(x = u)
      if (e > prune.SNN) {
        idx1[id] <- i
        idx2[id] <- nn.large[i, j]
        edge.weight[id] <- e
        id <- id + 1
      }
    }
    if (print.output) {
      setTxtProgressBar(pb = pb, value = i)
    }
  }
  if (print.output) {
    close(con = pb)
  }
  idx1 <- idx1[!is.na(x = idx1) & idx1 != 0]
  idx2 <- idx2[!is.na(x = idx2) & idx2 != 0]
  edge.weight <- edge.weight[!is.na(x = edge.weight) & edge.weight != 
                               0]
  w <- sparseMatrix(i = idx1, j = idx2, x = edge.weight, dims = c(n.cells, 
                                                                  n.cells))
  diag(x = w) <- 1
  rownames(x = w) <- cell.names
  colnames(x = w) <- cell.names
  return(w)
}
