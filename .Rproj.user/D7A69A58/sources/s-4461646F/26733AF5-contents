#' Helper function to compute lda using cellTree package
#'
#' @description This helper function is used to compute topics for an expression dataset using lda modelling
#' from cellTree package.
#' @param df spaceST object with expression data or data.frame.
#' @param max.topic Maximum number of topics.
#' @param num.genes Number of genes to use for lda modelling.
#' @param return.lda Set to TRUE if you want to return the "topics" object.
#' @param type Character string specifying if the "corrected" or "raw" data should be used as input. Default
#' is set to "corrected".
#' @return Topic matrix or "topics" object.
#' @rdname topic_compute
#' @export
topic_compute <- function(
  df,
  min.topic = 2,
  max.topic = 15,
  num.genes = NULL,
  type = "corrected",
  method = "maptpx",
  sd.filter = F,
  log.scale = F
) {
UseMethod("topic_compute")
}
#' @rdname topic_compute
#' @export
topic_compute.spaceST <- function(
  object,
  min.topic = 2,
  max.topic = 15,
  num.genes = NULL,
  type = "corrected",
  method = "maptpx",
  sd.filter = FALSE,
  log.scale = FALSE,
  force.recalc = FALSE
){
  if (length(object@corrected) > 0 & type == "corrected") {
    df <- object@corrected
  } else if (type == "raw") {
    df <- object@expr
  } else {
    stop("No corrected dataset present. Set dataset = 'raw' if you want to use the raw data")
  }
  omega <- topic_compute.default(
    df,
    min.topic = 2,
    max.topic = 15,
    num.genes = NULL,
    type = "corrected",
    method = "maptpx",
    sd.filter = F,
    log.scale = F
  )
  object@topics <- omega
  if (!length(object@meta.data) > 0 | force.recalc) {
    if (force.recalc) {
      warning("Overwriting LDA results.")
    }
    object@meta.data <- list()
  } else if (!length(object@meta.data) > 0 | !force.recalc) {
    warning("LDA method has already been computed for this object. Set force.calc = TRUE if you want to overwrite the results")
  }
  object@meta.data$clusters <- topic_clusters(omega = omega)
  object@meta.data$dist.method <- "Euclidean"
  object@meta.data$tree.method <- "Ward.D2"
  object@meta.data$minClusterSize <- 30
  return(object)
}
#' @rdname topic_compute
#' @export
topic_compute.default <- function(
  object,
  min.topic = 2,
  max.topic = 15,
  num.genes = NULL,
  type = "corrected",
  method = "maptpx",
  sd.filter = F,
  log.scale = F
){
  ave.exp = rowMeans(object)
  sort.ave.exp = sort(ave.exp, decreasing = T)
  if (!is.null(num.genes)) {
    high.ave.exp = sort.ave.exp[c(1:num.genes)]
    high.genes = names(high.ave.exp)
  } else {
    high.genes = names(sort.ave.exp)
  }
  GoM.sample.df = object[high.genes,]
  K = c(min.topic:max.topic)
  lda.results = cellTree::compute.lda(GoM.sample.df,
                                      k.topics = K,
                                      method = method,
                                      sd.filter = sd.filter,
                                      log.scale = log.scale)
  omega <- lda.results$omega
  return(omega)
}

#' Calculate clusters based on topics
#'
#' @description This function is used to cluster features based on a topics matrix.
#' @import dynamicTreeCut
#' @param omega Topic data.frame.
#' @param method.dist Set distance method.
#' @param method.tree Set clustering method.
#' @param minCLusterSize Integer value specifying the minimum cluster size allowed.
#' @return Integer vector specifying cluster identity of each feature.
#' @export
topic_clusters <- function(omega, method.dist = "euclidean", method.tree = "ward.D2", minClusterSize = 30){
  my.dist = dist(omega, method = method.dist)
  my.tree = hclust(my.dist, method = method.tree)
  clusters = unname(dynamicTreeCut::cutreeDynamic(my.tree, distM = as.matrix(my.dist), verbose = 0, minClusterSize = minClusterSize))
  return(clusters)
}

#' Plot heatmap of lda results
#'
#' @description This function is used to plot a heatmap of lda results.
#' @param df Topic data.frame (omega) or "topics" class object.
#' @param method.dist Set distance method.
#' @param method.tree Set clustering method.
#' @importFrom gplots heatmap.2
#' @return Heatmap of topic results.
#' @export
topic_heatmap <- function(df, method.dist = "euclidean", method.tree = "ward.D2", minClusterSize = 30){
  stopifnot(class(df) == "data.frame" | class(df) == "matrix" | class(df) == "topics")
  if (class(df) == "topics"){
    df <- df$omega
  }

  mycol = colorRampPalette(c("dark blue", "cyan", "yellow", "red"))(256)
  clusters = topic_clusters(df, method.dist = method.dist, method.tree = method.tree, minClusterSize = minClusterSize)
  #colors = c("#114477", "#4477AA", "#77AADD", "#117755", "#44AA88", "#99CCBB", "#777711", "#AAAA44", "#DDDD77", "#771111", "#AA4444", "#DD7777", "#771144", "#AA4477", "#DD77AA")
  colors = c("royalblue3",
             "mediumpurple4",
             "navajowhite2",
             "chocolate",
             "firebrick",
             "yellow2",
             "aquamarine",
             "orange1",
             "olivedrab2",
             "darkgreen",
             "pink",
             "black",
             "navy",
             "khaki3",
             "lightsteelblue1")
  clusters.col = colors[clusters]
  heatmap.2(
    t(df),
    key = TRUE,
    key.xlab = 'Identity',
    key.ylab = '',
    xlab = "feature",
    ylab = "topic",
    density.info='none',
    scale = 'none',
    trace = 'none',
    symbreaks = F,
    revC = F,
    cexRow = 0.7,
    cexCol = 0.35,
    symkey = 0,
    dendrogram = 'column',
    hclustfun = function(m)hclust(m, method = 'ward.D2'),
    distfun = function(m)dist(m,method = 'euclidean'),
    col = mycol,
    Rowv = F,
    ColSideColors = clusters.col)
}

#' Compute cluster matrix
#'
#' @description This function is used to pool clustered features by adding the gene expression values within each cluster.
#' @param df Expression data used to compute topics which will be pooled using cluster vector.
#' @param omega Topic data.frame (omega is used to calculate clusters on the fly using the topic.clusters function)
#' @param clusters Integer vector specifying cluster identity of each feature (if "clusters" is specified, the "omega" parameter is not needed).
#' @return Integer vector specifying cluster identity of each feature.
#' @export
topic_cluster_matrix <- function(df, omega = NULL, clusters = NULL){
  if (!(class(df) %in% c("data.frame", "matrix"))){
    stop("Wrong input format.")
  }
  #coordinates <- colnames(df)
  if (is.null(clusters) & is.null(omega)){
    stop("Either omega or clusters have to be specified.")
  }
  if (!is.null(clusters) & !is.null(omega)){
    print("Both omega and clusters have been specified. Chosing clusters...")
  }
  if (is.null(clusters) & !is.null(omega)){
    clusters = topic.clusters(omega)
  }
  clust.matrix <- rowsum(t(df), clusters)
  clust.matrix <- as.data.frame(t(clust.matrix))
  colnames(clust.matrix) <- paste(rep("c", length(unique(clusters))), 1:length(unique(clusters)), sep = "")
  return(clust.matrix)
}

#' QC plot for pooled data
#'
#' @description This function is used to plot a comparison of the number of unique genes before and after pooling.
#' @import ggplot2
#' @param expr Expression data used for clustering.
#' @param clust.df Cluster matrix obtained with topic.cluster.matrix function.
#' @param type Set type to compare, options; "genes", "transcripts"
#' @return Comparison plot between the number of unique genes in pooled clusters vs features.
#' @export
topic_cluster_QC_plot <- function(expr, clust.df, type = "genes"){
  if (!(class(expr) %in% c("data.frame", "matrix"))){
    stop("Wrong input format of expr.")
  }
  if (!(class(clust.df) %in% c("data.frame", "matrix"))){
    stop("Wrong input format of clust.df.")
  }

  if (type == "genes"){
    count.feature.df <- data.frame(apply(expr, 2, function(x) sum(x > 0)), as.factor(rep("feature", ncol(expr))))
    colnames(count.feature.df) <- c("count", "condition")

    count.clustered.df <- data.frame(apply(clust.df, 2, function(x) sum(x > 0)), as.factor(rep("clusters", ncol(clust.df))))
    colnames(count.clustered.df) <- c("count", "condition")

    counts.df <- rbind(count.feature.df, count.clustered.df)
  }
  if (type == "transcripts"){
    count.feature.df <- data.frame(colSums(expr), as.factor(rep("features", ncol(expr))))
    colnames(count.feature.df) <- c("count", "condition")

    count.clustered.df <- data.frame(colSums(clust.df), as.factor(rep("clusters", ncol(clust.df))))
    colnames(count.clustered.df) <- c("count", "condition")

    counts.df <- rbind(count.feature.df, count.clustered.df)
  }

  p <- ggplot2::ggplot(counts.df, ggplot2::aes(x = condition, y = count, fill = condition)) +
    ggplot2::geom_violin(scale = "width") +
    ggplot2::geom_boxplot(width = .1) +
    ggplot2::coord_flip() +
    ggplot2::facet_grid(~condition,scales='free') +
    ggplot2::theme_bw() +
    ggplot2::theme(axis.title.y = ggplot2::element_blank(),
                   axis.text.y = ggplot2::element_blank(),
                   axis.ticks.y = ggplot2::element_blank(),
                   axis.text.x = ggplot2::element_text(angle = 60, vjust = 0.5)) +
    ggplot2::scale_fill_manual(values = c("#009E73", "#56B4E9"))
  if (type == "genes"){
    p <- p + ggplot2::labs(y = "number of unique genes")
  } else if (type == "transcripts"){
    p <- p + ggplot2::labs(y = "number of transcripts")
  }
  return(p)
}
